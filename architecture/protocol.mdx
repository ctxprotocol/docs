---
title: "Protocol Architecture"
description: "How the settlement layer, read-only safety, and staking system work together"
---

## Overview

Context is built on a **Code Execution paradigm**. Instead of rigid "tool calling" schemas, the Agent writes and executes TypeScript code to interact with the world.

The architecture consists of four layers:

1. **The Marketplace** — Supply of tools from developers
2. **The Agent** — Demand from users executing queries
3. **The Protocol** — Settlement layer on Base
4. **Context Injection** — User data for personalized tools

---

## The Marketplace (Supply)

Developers register **Tools** (the paid product) powered by standard Model Context Protocol servers. Just paste your endpoint URL and we auto-discover your skills via `listTools()`.

### Terminology

| Term | Definition |
|------|------------|
| **Tool** | The paid marketplace listing (what users see in the sidebar) |
| **Skill** | The execution function (can be called multiple times per tool payment) |

### How It Works

1. You build an MCP server exposing your data/APIs
2. You register it as an "MCP Tool" on Context with a price (e.g., \$0.01/query)
3. When users query the AI, it discovers and calls your skills via `callMcpSkill()`
4. You get paid in USDC on Base via deferred settlement (after successful execution)

---

## The Data Broker Standard

<Warning>
Context is not a text-based chat platform — it is a **Structured Data Marketplace**. We treat your tool like a financial API, not a conversational bot.
</Warning>

### Why `outputSchema` and `structuredContent` Matter

The MCP specification defines `outputSchema` and `structuredContent` as optional features for tools. **Context requires them for all paid tools** because structured data enables powerful marketplace features:

| Feature | Without Schema | With Schema |
|---------|----------------|-------------|
| AI Code Generation | Agent guesses response format | Agent writes precise parsing code |
| Type Safety | Runtime errors, broken parsing | Guaranteed structure |
| Dispute Resolution | Manual review required | Auto-adjudicated on-chain |
| Trust Signal | Unknown reliability | "Data Broker" verified |

### Why Context Requires These Fields

While optional in vanilla MCP, Context requires structured outputs because:

- **AI Agent Benefit**: The agent uses your `outputSchema` to write accurate TypeScript code that parses your response correctly.
- **Payment Verification**: Our smart contracts can verify that your returned JSON matches your promised schema.
- **Dispute Resolution**: Schema mismatches can be auto-adjudicated on-chain without manual review.

<Info>
**Result:** You are not just a "Prompt Engineer" — you are a **Data Broker** selling verifiable information on-chain.
</Info>

---

## The Agent (Demand)

When a user asks a complex question (e.g., *"Is it profitable to arb Uniswap vs Aave?"*), the Agent:

<Steps>
  <Step title="Discover">
    Finds relevant tools from the marketplace (or uses pre-selected ones)
  </Step>
  <Step title="Plan">
    Creates a solution using composability
  </Step>
  <Step title="Write Code">
    Generates code to invoke the necessary paid Tools via `callMcpSkill()`
  </Step>
  <Step title="Execute">
    Runs the code securely in our sandbox
  </Step>
  <Step title="Synthesize">
    Combines results into a coherent answer and streams it to the user
  </Step>
  <Step title="Settle">
    After the response is delivered, payment is settled in the background via `ContextRouter` (deferred settlement — tool fees are waived if execution fails)
  </Step>
</Steps>

<Note>
**Composability is the superpower of Context.** Any frontier model can stitch together disparate tools into a coherent workflow, creating infinite new use cases from your single MCP server.
</Note>

---

## The Protocol (Settlement)

All value flows through `ContextRouter.sol` on Base using **deferred settlement**.

### How Settlement Works

1. User sets a **spending cap** (ERC-20 allowance on ContextRouter) — this is a one-time setup
2. Before execution, the server performs a **read-only pre-flight check** (balance + allowance) — no gas cost
3. Tools execute and the AI response is streamed to the user
4. **After the response is fully delivered**, the server settles payment in the background via the operator wallet
5. If settlement fails, it is retried automatically (up to 5 attempts with exponential backoff)

<Info>
**Key benefit:** Users never wait for on-chain transactions. They get their response immediately, and settlement happens asynchronously. Tool fees are waived if execution fails — users only pay for successful results.
</Info>

### Payment Distribution

| Recipient | Share |
|-----------|-------|
| Tool Developer | 90% |
| Protocol Treasury | 10% |

When multiple tools are used, payments are **batched into a single transaction**.

---

## Staking System

All tools (including free) require a minimum stake, enforced on-chain.

| Tool Type | Minimum Stake |
|-----------|---------------|
| Free Tools | \$10 USDC |
| Paid Tools | \$10 USDC or 100× query price (whichever is higher) |

### Stake Properties

- **Fully refundable** with a 7-day withdrawal delay
- **Creates accountability** and enables slashing for fraud
- **On-chain enforcement** via smart contracts

---

## Security: Financial Protocol Architecture

We use **Asymmetric Request Signing (RS256)** to secure the marketplace. This is not just "auth" — it's the foundation of a financial protocol.

### Free vs Paid Requirements

| Tool Type | Security Middleware | Rationale |
|-----------|---------------------|-----------|
| **Free Tools ($0.00)** | **Optional** | Great for distribution and adoption |
| **Paid Tools ($0.01+)** | **Mandatory** | We cannot route payments to insecure endpoints |

<Info>
If you're building a free tool, you can skip security middleware entirely. But for paid tools, the middleware ensures that only legitimate, paid requests from the Context platform can execute your code.
</Info>

### Why This Matters (for Paid Tools)

| Approach | Result |
|----------|--------|
| Without Auth | A toy — anyone can `curl` your endpoint |
| With Shared Secrets | A security liability — secrets can leak |
| With Asymmetric Signing | Professional infrastructure (like Stripe/Visa) |

### How It Works

1. **Platform signs requests** with a private key (stored securely in environment)
2. **Tool servers verify requests** using the public key (distributed via SDK)
3. **Short-lived tokens** (2-minute expiration) prevent replay attacks

### JWT Claims

| Claim | Description |
|-------|-------------|
| `iss` | `https://ctxprotocol.com` (issuer) |
| `aud` | Tool endpoint URL (audience) |
| `toolId` | Database ID of the tool being called |
| `iat` | Issue timestamp |
| `exp` | Expiration (2 minutes from issue) |

### For MCP Tool Developers

Secure your endpoint with a single line:

```typescript
import { createContextMiddleware } from "@ctxprotocol/sdk";

// 1 line to secure your endpoint
app.use("/mcp", createContextMiddleware());
```

---

## Context Injection (User Data)

For tools that need access to user-specific data (e.g., *"Analyze my positions"* or *"Check my balances"*), Context uses a **Context Injection** pattern. The platform fetches user data client-side and injects it directly into your tool's arguments — your server never sees private keys or credentials.

| Context Type | Description |
|--------------|-------------|
| `"hyperliquid"` | Hyperliquid perpetuals & spot positions |
| `"polymarket"` | Polymarket prediction markets |
| `"wallet"` | Generic EVM wallet balances |

<Card title="Context Injection Guide" icon="syringe" href="/guides/context-injection">
  Full guide: declaring requirements, handling data, supported context types
</Card>

---

## Tool Safety Limits

Each tool invocation runs inside a **sandboxed code-execution environment**.

### MCP Tools Limits

| Limit | Value | Purpose |
|-------|-------|---------|
| Max calls per turn | 100 | Prevent runaway loops |
| VM timeout | 5000ms | Code execution limit |
| **MCP execution timeout** | **~60 seconds** | Encourages pre-computed products |

Every `callMcpSkill({ toolId, toolName, args })` increments an internal counter. Once `executionCount >= 100`, the platform throws an error for that turn.

<Warning>
**The ~60 second timeout is intentional.** This limit is enforced at the platform/client level (not by MCP itself) and serves as a quality forcing function. It encourages data brokers to build pre-computed insight products rather than raw data access tools.

See [Build & List Your Tool](/guides/build-tools#execution-limits--product-design) for detailed guidance on product architecture.
</Warning>

### Economic Model

| Scenario | Behavior |
|----------|----------|
| Free tools (\$0.00) | Can be used immediately without payment |
| Paid tools | Require a spending cap (ERC-20 allowance on ContextRouter) |
| Multiple paid tools | Single batched settlement transaction |
| Execution fails | Tool fees are **waived** — only model cost is settled (convenience tier) |
| Settlement fails | Retried automatically (up to 5 attempts), then platform absorbs |

---

## SDK Payment Modes

The SDKs offer two distinct payment models, reflecting Context's dual role as both an API marketplace and a response marketplace:

| Mode | Endpoint | Payment | What You Get |
|------|----------|---------|--------------|
| **Execute** (`client.tools.execute()`) | `/api/v1/tools/execute` | Pay-per-request | Raw data from a single tool call |
| **Query** (`client.query.run()`) | `/api/v1/query` | Pay-per-response | AI-synthesized answer from the full agentic pipeline |

**Execute** is for precision — you call a specific tool with specific arguments and get raw data back. One call, one payment, one result. Good for building custom pipelines.

**Query** is for intelligence — you ask a natural-language question, and the server handles tool discovery, multi-tool orchestration (up to 100 MCP calls per tool), self-healing retries, completeness checks, and AI synthesis. One flat fee, curated answer. This is the same agentic pipeline that powers the client app.

<Info>
**Why offer both?** Different consumers have different needs. An agent building a custom trading strategy wants raw data and full control (Execute). An agent answering user questions wants curated intelligence without managing orchestration (Query). Context serves both.</Info>

