---
title: "TypeScript SDK Reference"
description: "Complete API reference for @ctxprotocol/sdk — installation, configuration, methods, and types"
---

<Note>
Looking for Python? Check out the [Python SDK Reference](/sdk/python-reference).
</Note>

## Installation

<CodeGroup>
```bash npm
npm install @ctxprotocol/sdk
```

```bash pnpm
pnpm add @ctxprotocol/sdk
```

```bash yarn
yarn add @ctxprotocol/sdk
```
</CodeGroup>

### Requirements

- Node.js 18+ (for native fetch)
- TypeScript 5+ (recommended)

---

## Prerequisites

Before using the API, complete setup at [ctxprotocol.com](https://ctxprotocol.com):

<Steps>
  <Step title="Sign in">
    Creates your embedded wallet
  </Step>
  <Step title="Set spending cap">
    Approve USDC spending on the ContextRouter (one-time setup)
  </Step>
  <Step title="Fund wallet">
    Add USDC for tool execution fees
  </Step>
  <Step title="Generate API key">
    In Settings page
  </Step>
</Steps>

---

## Two SDK Modes

The SDK offers two payment models to serve different use cases:

| Mode | Method | Payment Model | Use Case |
|------|--------|---------------|----------|
| **Execute** | `client.tools.execute()` | Pay-per-request | Simple data fetches, predictable costs, building custom pipelines |
| **Query** | `client.query.run()` | Pay-per-response | Complex questions, multi-tool synthesis, curated intelligence |

<Info>
**Which should I use?** Use **Query** when you want a curated answer to a complex question — the server handles tool discovery, multi-tool orchestration (up to 100 MCP calls per tool), self-healing retries, and AI synthesis for one flat fee. Use **Execute** when you want raw data from a specific tool with full control over the pipeline.
</Info>

## Quick Start

```typescript
import { ContextClient } from "@ctxprotocol/sdk";

const client = new ContextClient({
  apiKey: "sk_live_...",
});

// Pay-per-response: Ask a question, get a curated answer
const answer = await client.query.run("What are the top whale movements on Base?");
console.log(answer.response);

// Pay-per-request: Execute a specific tool for raw data
const tools = await client.discovery.search("gas prices");
const result = await client.tools.execute({
  toolId: tools[0].id,
  toolName: tools[0].mcpTools[0].name,
  args: { chainId: 1 },
});
console.log(result.result);
```

---

## Configuration

### Client Options

| Option | Type | Required | Default | Description |
|--------|------|----------|---------|-------------|
| `apiKey` | `string` | Yes | — | Your Context Protocol API key |
| `baseUrl` | `string` | No | `https://ctxprotocol.com` | API base URL (for development) |

```typescript
// Production
const client = new ContextClient({
  apiKey: process.env.CONTEXT_API_KEY!,
});

// Local development
const client = new ContextClient({
  apiKey: "sk_test_...",
  baseUrl: "http://localhost:3000",
});
```

---

## API Reference

### Discovery

#### `client.discovery.search(query, limit?)`

Search for tools matching a query string.

**Parameters:**
| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `query` | `string` | Yes | Search query |
| `limit` | `number` | No | Maximum results to return |

**Returns:** `Promise<Tool[]>`

```typescript
const tools = await client.discovery.search("ethereum gas", 10);
```

---

#### `client.discovery.getFeatured(limit?)`

Get featured/popular tools.

**Parameters:**
| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `limit` | `number` | No | Maximum results to return |

**Returns:** `Promise<Tool[]>`

```typescript
const featured = await client.discovery.getFeatured(5);
```

---

### Tools (Pay-Per-Request)

#### `client.tools.execute(options)`

Execute a single tool method. One call, one payment, raw result.

**Parameters:**
| Option | Type | Required | Description |
|--------|------|----------|-------------|
| `toolId` | `string` | Yes | UUID of the tool |
| `toolName` | `string` | Yes | Name of the method to call |
| `args` | `object` | No | Arguments matching the tool's `inputSchema` |
| `idempotencyKey` | `string` | No | Optional idempotency key (UUID recommended) |

**Returns:** `Promise<ExecutionResult>`

```typescript
const result = await client.tools.execute({
  toolId: "uuid-of-tool",
  toolName: "get_gas_prices",
  args: { chainId: 1 },
  idempotencyKey: crypto.randomUUID(),
});
```

---

### Query (Pay-Per-Response)

<Info>
The Query API is Context's **response marketplace** — instead of buying raw API calls, you're buying curated intelligence. Ask a question, pay once, and get an AI-synthesized answer backed by multi-tool data aggregation, error recovery, and completeness checks.
</Info>

#### `client.query.run(options)`

Run an agentic query. The server discovers tools, executes the full pipeline (up to 100 MCP calls per tool), applies model-aware mediator/data budgeting, and returns an AI-synthesized answer. Payment is settled after successful execution.

**Parameters:**
| Option | Type | Required | Description |
|--------|------|----------|-------------|
| `query` | `string` | Yes | Natural-language question |
| `tools` | `string[]` | No | Tool IDs to use (auto-discover if omitted) |
| `modelId` | `string` | No | Model ID to use for planning/synthesis (e.g. `kimi-model-thinking`, `glm-model`) |
| `includeData` | `boolean` | No | Include execution data inline in the response |
| `includeDataUrl` | `boolean` | No | Persist execution data to blob and return a URL |
| `idempotencyKey` | `string` | No | Optional idempotency key (UUID recommended) |

Can also accept a plain string: `client.query.run("your question")`

**Returns:** `Promise<QueryResult>`

```typescript
const answer = await client.query.run("What are the top whale movements on Base?");
console.log(answer.response);     // AI-synthesized text
console.log(answer.toolsUsed);    // [{ id, name, skillCalls }]
console.log(answer.cost);         // { modelCostUsd, toolCostUsd, totalCostUsd }
```

```typescript
const answer = await client.query.run({
  query: "Analyze whale activity on Base",
  modelId: "glm-model",
  includeData: true,
  includeDataUrl: true,
  idempotencyKey: crypto.randomUUID(),
});
```

<Note>
`modelId` lets headless users choose the orchestration/synthesis model explicitly. If omitted, the API uses its default model.

Current platform IDs: `kimi-model-thinking`, `glm-model`, `gemini-flash-model`, `claude-sonnet-model`, `claude-opus-model`.
</Note>

#### `client.query.stream(options)`

Same as `run()` but streams events in real-time via SSE.

**Returns:** `AsyncGenerator<QueryStreamEvent>`

```typescript
for await (const event of client.query.stream("What are the top whale movements?")) {
  switch (event.type) {
    case "tool-status":
      console.log(`Tool ${event.tool.name}: ${event.status}`);
      break;
    case "text-delta":
      process.stdout.write(event.delta);
      break;
    case "done":
      console.log("\nTotal cost:", event.result.cost.totalCostUsd);
      break;
  }
}
```

<Note>
Use the same `idempotencyKey` when retrying the same logical request after network/timeout failures.
</Note>

---

## Types

### Import Types

```typescript
import {
  // Auth utilities for tool contributors
  verifyContextRequest,
  isProtectedMcpMethod,
  isOpenMcpMethod,
} from "@ctxprotocol/sdk";

import type {
  // Client types
  ContextClientOptions,
  Tool,
  McpTool,
  McpToolMeta,
  McpToolRateLimitHints,
  ExecuteOptions,
  ExecutionResult,
  ContextErrorCode,
  // Auth types (for MCP server contributors)
  VerifyRequestOptions,
  // Context types (for MCP server contributors receiving injected data)
  ContextRequirementType,
  HyperliquidContext,
  PolymarketContext,
  WalletContext,
  UserContext,
} from "@ctxprotocol/sdk";
```

---

### Tool

```typescript
interface Tool {
  id: string;
  name: string;
  description: string;
  price: string;
  category?: string;
  isVerified?: boolean;
  mcpTools?: McpTool[];
}
```

---

### McpTool

```typescript
interface McpTool {
  name: string;
  description: string;
  inputSchema?: Record<string, unknown>;  // JSON Schema for arguments
  outputSchema?: Record<string, unknown>; // JSON Schema for response
  _meta?: McpToolMeta;                    // context + pacing metadata
}

interface McpToolRateLimitHints {
  maxRequestsPerMinute?: number;
  maxConcurrency?: number;
  cooldownMs?: number;
  supportsBulk?: boolean;
  recommendedBatchTools?: string[];
  notes?: string;
}

interface McpToolMeta {
  contextRequirements?: ContextRequirementType[];
  rateLimit?: McpToolRateLimitHints;
  rateLimitHints?: McpToolRateLimitHints;
}
```

---

### ExecutionResult (Pay-Per-Request)

```typescript
interface ExecutionResult<T = unknown> {
  result: T;
  tool: { id: string; name: string };
  durationMs: number;
}
```

---

### QueryResult (Pay-Per-Response)

```typescript
interface QueryResult {
  response: string;                    // AI-synthesized answer
  toolsUsed: QueryToolUsage[];         // [{ id, name, skillCalls }]
  cost: QueryCost;                     // { modelCostUsd, toolCostUsd, totalCostUsd }
  durationMs: number;
  data?: unknown;                      // Optional execution data (includeData=true)
  dataUrl?: string;                    // Optional blob URL (includeDataUrl=true)
}
```

---

### Context Requirement Types

For MCP server contributors building tools that need user context (e.g., wallet data, portfolio positions):

<Info>
**Why Context Injection Matters:**

- **No Auth Required**: Public blockchain/user data is fetched by the platform, so you don't need to handle API keys or user login.
- **Security**: Your MCP server never handles private keys or sensitive credentials.
- **Simplicity**: You receive structured, type-safe data directly in your tool arguments.
</Info>

```typescript
import type { ContextRequirementType } from "@ctxprotocol/sdk";

/** Context types supported by the marketplace */
type ContextRequirementType = "polymarket" | "hyperliquid" | "wallet";

// Usage: Declare context requirements in _meta at the tool level (MCP spec)
const TOOLS = [{
  name: "analyze_my_positions",
  description: "Analyze your positions with personalized insights",

  // ⭐ REQUIRED: Context requirements in _meta (MCP spec for arbitrary metadata)
  // The Context platform reads this to inject user data + pacing hints
  _meta: {
    contextRequirements: ["hyperliquid"] as ContextRequirementType[],
    rateLimit: {
      maxRequestsPerMinute: 30,
      cooldownMs: 2000,
      maxConcurrency: 1,
      supportsBulk: true,
      recommendedBatchTools: ["get_portfolio_snapshot"],
      notes: "Hobby tier: use snapshot methods before per-asset loops.",
    },
  },

  inputSchema: {
    type: "object",
    properties: {
      portfolio: { 
        type: "object",
        description: "Portfolio context (injected by platform)",
      },
    },
    required: ["portfolio"],
  },
  outputSchema: { /* ... */ },
}];
```

<Info>
**Why `_meta` at the tool level?** The `_meta` field is part of the [MCP specification](https://modelcontextprotocol.io/specification/2025-11-25/server/tools#tool-definition) for arbitrary tool metadata. The Context platform reads `_meta.contextRequirements` for context injection and `_meta.rateLimit` / `_meta.rateLimitHints` for planner/runtime pacing behavior. This is preserved through MCP transport because it's a standard field.
</Info>

<Info>
Reference implementation: [Coinglass contributor server](https://github.com/ctxprotocol/sdk/tree/main/examples/server/coinglass-contributor).
</Info>

---

### Injected Context Types

#### HyperliquidContext

```typescript
interface HyperliquidContext {
  walletAddress: string;
  perpPositions: HyperliquidPerpPosition[];
  spotBalances: HyperliquidSpotBalance[];
  openOrders: HyperliquidOrder[];
  accountSummary: HyperliquidAccountSummary;
  fetchedAt: string;
}
```

#### PolymarketContext

```typescript
interface PolymarketContext {
  walletAddress: string;
  positions: PolymarketPosition[];
  openOrders: PolymarketOrder[];
  totalValue?: number;
  fetchedAt: string;
}
```

#### WalletContext

```typescript
interface WalletContext {
  address: string;
  chainId: number;
  balances: TokenBalance[];
  fetchedAt: string;
}
```

---

## Error Handling

The SDK throws `ContextError` with specific error codes:

```typescript
import { ContextError } from "@ctxprotocol/sdk";

try {
  const result = await client.tools.execute({ ... });
} catch (error) {
  if (error instanceof ContextError) {
    switch (error.code) {
      case "no_wallet":
        // User needs to set up wallet
        console.log("Setup required:", error.helpUrl);
        break;
      case "insufficient_allowance":
        // User needs to set a spending cap
        console.log("Set spending cap:", error.helpUrl);
        break;
      case "payment_failed":
        // Insufficient USDC balance
        break;
      case "execution_failed":
        // Tool execution error
        break;
    }
  }
}
```

### Error Codes

| Code | Description | Handling |
|------|-------------|----------|
| `unauthorized` | Invalid API key | Check configuration |
| `no_wallet` | Wallet not set up | Direct user to `helpUrl` |
| `insufficient_allowance` | Spending cap not set | Direct user to `helpUrl` |
| `payment_failed` | USDC payment failed | Check balance |
| `execution_failed` | Tool error | Retry with different args |

---

## Securing Your Tool (MCP Contributors)

If you're building an MCP server, verify incoming requests are legitimate.

<Info>
**Free vs Paid Security Requirements:**

| Tool Type | Security Middleware | Rationale |
|-----------|---------------------|-----------|
| **Free Tools ($0.00)** | **Optional** | Great for distribution and adoption |
| **Paid Tools ($0.01+)** | **Mandatory** | We cannot route payments to insecure endpoints |
</Info>

### Quick Implementation

```typescript
import express from "express";
import { createContextMiddleware } from "@ctxprotocol/sdk";

const app = express();
app.use(express.json());

// 1 line of code to secure your endpoint
app.use("/mcp", createContextMiddleware());

app.post("/mcp", (req, res) => {
  // req.context contains verified JWT payload (on protected methods)
  // Handle MCP request...
});
```

### MCP Security Model

<Warning>
**Critical for tool contributors:** Not all MCP methods require authentication. The middleware **selectively** protects only execution methods.
</Warning>

| MCP Method | Auth Required | Why |
|------------|---------------|-----|
| `initialize` | ❌ No | Session setup |
| `tools/list` | ❌ No | Discovery - agents need to see your schemas |
| `resources/list` | ❌ No | Discovery |
| `prompts/list` | ❌ No | Discovery |
| `tools/call` | ✅ **Yes** | **Execution - costs money, runs your code** |

<Info>
**What this means in practice:**
- ✅ `https://your-mcp.com/mcp` + `initialize` → Works without auth
- ✅ `https://your-mcp.com/mcp` + `tools/list` → Works without auth  
- ❌ `https://your-mcp.com/mcp` + `tools/call` → **Requires Context Protocol JWT**

This matches standard API patterns (OpenAPI schemas are public, GraphQL introspection is open).
</Info>

### Manual Verification

For more control, use the lower-level utilities:

```typescript
import { 
  verifyContextRequest, 
  isProtectedMcpMethod, 
  ContextError 
} from "@ctxprotocol/sdk";

// Check if a method requires auth
if (isProtectedMcpMethod(body.method)) {
  const payload = await verifyContextRequest({
    authorizationHeader: req.headers.authorization,
    audience: "https://your-tool.com/mcp", // optional
  });
  // payload contains verified JWT claims
}
```

### Verification Options

| Option | Type | Required | Description |
|--------|------|----------|-------------|
| `authorizationHeader` | `string` | Yes | Full Authorization header (e.g., `"Bearer eyJ..."`) |
| `audience` | `string` | No | Expected audience claim for stricter validation |

---

## Payment Flow

Context supports two settlement timings:

1. **Query mode (`client.query.*`)** uses deferred settlement after the response is delivered
2. **Execute mode (`client.tools.execute`)** currently settles before the single MCP call
3. In both modes, spending caps are enforced via ContextRouter allowance checks
4. **90%** goes to the tool developer, **10%** goes to the protocol

---

## Links

- [Context Protocol](https://ctxprotocol.com) — Main website
- [NPM Package](https://www.npmjs.com/package/@ctxprotocol/sdk)
- [GitHub (TypeScript SDK)](https://github.com/ctxprotocol/sdk)
- [Python SDK](/sdk/python-reference) — For Python developers

