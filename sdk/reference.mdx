---
title: "TypeScript SDK Reference"
description: "Complete API reference for @ctxprotocol/sdk — installation, configuration, methods, and types"
---

<Note>
Looking for Python? Check out the [Python SDK Reference](/sdk/python-reference).
</Note>

## Installation

<CodeGroup>
```bash npm
npm install @ctxprotocol/sdk
```

```bash pnpm
pnpm add @ctxprotocol/sdk
```

```bash yarn
yarn add @ctxprotocol/sdk
```
</CodeGroup>

### Requirements

- Node.js 18+ (for native fetch)
- TypeScript 5+ (recommended)

---

## Prerequisites

Before using the API, complete setup at [ctxprotocol.com](https://ctxprotocol.com):

<Steps>
  <Step title="Sign in">
    Creates your embedded wallet
  </Step>
  <Step title="Set spending cap">
    Approve USDC spending on the ContextRouter (one-time setup)
  </Step>
  <Step title="Fund wallet">
    Add USDC for tool execution fees
  </Step>
  <Step title="Generate API key">
    In Settings page
  </Step>
</Steps>

---

## Quick Start

```typescript
import { ContextClient } from "@ctxprotocol/sdk";

const client = new ContextClient({
  apiKey: "sk_live_...",
});

const answer = await client.query.run("What are the top whale movements on Base?");
console.log(answer.response);
```

<Info>
**Want per-call pricing and spending limits?** The SDK also supports [Execute mode](#tools-execute-mode) for direct method calls inside session budgets. See [Two SDK Modes](#two-sdk-modes) below.
</Info>

---

## Two SDK Modes

The SDK offers two payment models:

| Mode | Method | Payment Model | Use Case |
|------|--------|---------------|----------|
| **Query** | `client.query.run()` | Pay-per-response | Complex questions, multi-tool synthesis, curated intelligence |
| **Execute** | `client.tools.execute()` | Per call (with spending limit) | Deterministic pipelines, raw outputs, explicit cost control |

<Info>
**You have access to both modes — pick the one that fits your use case.**

- Use **Query** (`client.query.run()`) when you want a curated answer — Context is the librarian and handles discovery/orchestration (up to 100 MCP calls per response turn). Pay-per-response (~$0.10).
- Use **Execute** (`client.tools.execute()`) when your app/agent is the librarian and you want per-call pricing with spending limits (~$0.001/call).

Most developers start with Query and add Execute later for specific pipelines that need raw data or explicit cost control. You can use both in the same application.
</Info>

### Execute Quick Start

```typescript
const executeTools = await client.discovery.search({
  query: "gas prices",
  mode: "execute",
  surface: "execute",
  requireExecutePricing: true,
});

const method = executeTools[0]?.mcpTools?.[0];
if (!method) throw new Error("No execute method available");

const session = await client.tools.startSession({ maxSpendUsd: "1.00" });
const result = await client.tools.execute({
  toolId: executeTools[0].id,
  toolName: method.name,
  args: { chainId: 1 },
  sessionId: session.session.sessionId ?? undefined,
});
console.log(result.result);
console.log(result.session); // methodPrice, spent, remaining, maxSpend, status...
```

<Note>
Mixed listings are first-class: one listing can expose methods to both modes. Methods without explicit execute pricing remain discoverable for Query but are excluded from Execute discovery when `requireExecutePricing=true`.
</Note>

<Note>
Compatibility: payload fields like `price` and `pricePerQuery` are kept for backward compatibility. In Query mode, they represent listing-level **price per response turn**.
A future major release can add response-named aliases (for example, `pricePerResponse`) before deprecating legacy names.
</Note>

---

## Configuration

### Client Options

| Option | Type | Required | Default | Description |
|--------|------|----------|---------|-------------|
| `apiKey` | `string` | Yes | — | Your Context Protocol API key |
| `baseUrl` | `string` | No | `https://ctxprotocol.com` | API base URL (for development) |

```typescript
// Production
const client = new ContextClient({
  apiKey: process.env.CONTEXT_API_KEY!,
});

// Local development
const client = new ContextClient({
  apiKey: "sk_test_...",
  baseUrl: "http://localhost:3000",
});
```

---

## API Reference

### Discovery

#### `client.discovery.search(query, limit?)`
#### `client.discovery.search(options)`

Search for tools matching a query string, or pass an options object for mode-aware filtering.

**Parameters (string signature):**
| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `query` | `string` | Yes | Search query |
| `limit` | `number` | No | Maximum results to return |

**Parameters (options signature):**
| Option | Type | Required | Description |
|--------|------|----------|-------------|
| `query` | `string` | No | Search query (empty for featured-style searches) |
| `limit` | `number` | No | Maximum results to return |
| `mode` | `"query" \| "execute"` | No | Discovery mode with billing semantics |
| `surface` | `"answer" \| "execute" \| "both"` | No | Method mode filter |
| `queryEligible` | `boolean` | No | Require methods that are query-safe |
| `requireExecutePricing` | `boolean` | No | Require explicit method execute pricing |
| `excludeLatencyClasses` | `("instant" \| "fast" \| "slow" \| "streaming")[]` | No | Exclude by latency class |
| `excludeSlow` | `boolean` | No | Convenience filter for query mode |

**Returns:** `Promise<Tool[]>`

```typescript
const tools = await client.discovery.search("ethereum gas", 10);

const executeTools = await client.discovery.search({
  query: "ethereum gas",
  mode: "execute",
  surface: "execute",
  requireExecutePricing: true,
});
```

---

#### `client.discovery.getFeatured(limit?, options?)`

Get featured/popular tools.

**Parameters:**
| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `limit` | `number` | No | Maximum results to return |
| `options` | `Omit<SearchOptions, "query" \| "limit">` | No | Optional mode filters |

**Returns:** `Promise<Tool[]>`

```typescript
const featured = await client.discovery.getFeatured(5);
const featuredExecute = await client.discovery.getFeatured(5, {
  mode: "execute",
  requireExecutePricing: true,
});
```

---

### Tools (Execute Mode)

#### `client.tools.execute(options)`

Execute a single tool method. Execute calls can run inside a session budget (`maxSpendUsd`) with automatic payment after delivery.

**Parameters:**
| Option | Type | Required | Description |
|--------|------|----------|-------------|
| `toolId` | `string` | Yes | UUID of the tool |
| `toolName` | `string` | Yes | Name of the method to call |
| `args` | `object` | No | Arguments matching the tool's `inputSchema` |
| `idempotencyKey` | `string` | No | Optional idempotency key (UUID recommended) |
| `mode` | `"execute"` | No | Explicit mode label (defaults to `"execute"`) |
| `sessionId` | `string` | No | Execute session ID to accrue spend against |
| `maxSpendUsd` | `string` | No | Optional inline session budget (if no `sessionId`) |
| `closeSession` | `boolean` | No | Request session closure after this call settles |

**Returns:** `Promise<ExecutionResult>`

```typescript
const session = await client.tools.startSession({ maxSpendUsd: "2.50" });

const result = await client.tools.execute({
  toolId: "uuid-of-tool",
  toolName: "get_gas_prices",
  args: { chainId: 1 },
  idempotencyKey: crypto.randomUUID(),
  sessionId: session.session.sessionId ?? undefined,
});

console.log(result.method.executePriceUsd); // explicit method price
console.log(result.session); // { methodPrice, spent, remaining, maxSpend, ... }
```

#### `client.tools.startSession({ maxSpendUsd })`

Start an execute session budget envelope.

```typescript
const started = await client.tools.startSession({ maxSpendUsd: "5.00" });
console.log(started.session.sessionId);
console.log(started.session.maxSpend);
```

#### `client.tools.getSession(sessionId)`

Fetch current execute session status/spend.

```typescript
const status = await client.tools.getSession("sess_123");
console.log(status.session.status); // open | closed | expired
console.log(status.session.spent);
```

#### `client.tools.closeSession(sessionId)`

Close an execute session and trigger final flush behavior.

```typescript
const closed = await client.tools.closeSession("sess_123");
console.log(closed.session.status); // closed
```

---

### Query (Pay-Per-Response)

<Info>
The Query API is Context's **response marketplace** — instead of buying raw API calls, you're buying curated intelligence. Ask a question, pay once, and get an AI-synthesized answer backed by multi-tool data aggregation, error recovery, and completeness checks.
</Info>

#### `client.query.run(options)`

Run an agentic query. The server discovers query-eligible tools, executes the full pipeline (up to 100 MCP calls per response turn as a runtime safety cap), applies model-aware mediator/data budgeting, and returns an AI-synthesized answer. Query billing is pay-per-response with automatic payment after delivery.

**Parameters:**
| Option | Type | Required | Description |
|--------|------|----------|-------------|
| `query` | `string` | Yes | Natural-language question |
| `tools` | `string[]` | No | Tool IDs to use (auto-discover if omitted) |
| `modelId` | `string` | No | Model ID to use for planning/synthesis (e.g. `kimi-model-thinking`, `glm-model`) |
| `includeData` | `boolean` | No | Include execution data inline in the response |
| `includeDataUrl` | `boolean` | No | Persist execution data to blob and return a URL |
| `idempotencyKey` | `string` | No | Optional idempotency key (UUID recommended) |

Can also accept a plain string: `client.query.run("your question")`

**Returns:** `Promise<QueryResult>`

```typescript
const answer = await client.query.run("What are the top whale movements on Base?");
console.log(answer.response);     // AI-synthesized text
console.log(answer.toolsUsed);    // [{ id, name, skillCalls }]
console.log(answer.cost);         // { modelCostUsd, toolCostUsd, totalCostUsd }
```

```typescript
const answer = await client.query.run({
  query: "Analyze whale activity on Base",
  modelId: "glm-model",
  includeData: true,
  includeDataUrl: true,
  idempotencyKey: crypto.randomUUID(),
});
```

<Note>
`modelId` lets headless users choose the orchestration/synthesis model explicitly. If omitted, the API uses its default model.

Current platform IDs: `kimi-model-thinking`, `glm-model`, `gemini-flash-model`, `claude-sonnet-model`, `claude-opus-model`.
</Note>

#### `client.query.stream(options)`

Same as `run()` but streams events in real-time via SSE.

**Returns:** `AsyncGenerator<QueryStreamEvent>`

```typescript
for await (const event of client.query.stream("What are the top whale movements?")) {
  switch (event.type) {
    case "tool-status":
      console.log(`Tool ${event.tool.name}: ${event.status}`);
      break;
    case "text-delta":
      process.stdout.write(event.delta);
      break;
    case "done":
      console.log("\nTotal cost:", event.result.cost.totalCostUsd);
      break;
  }
}
```

<Note>
Use the same `idempotencyKey` when retrying the same logical request after network/timeout failures.
</Note>

---

## Types

### Import Types

```typescript
import {
  // Auth utilities for tool contributors
  verifyContextRequest,
  isProtectedMcpMethod,
  isOpenMcpMethod,
} from "@ctxprotocol/sdk";

import type {
  // Client types
  ContextClientOptions,
  Tool,
  McpTool,
  McpToolMeta,
  McpToolRateLimitHints,
  ExecuteOptions,
  ExecutionResult,
  ContextErrorCode,
  // Auth types (for MCP server contributors)
  VerifyRequestOptions,
  // Context types (for MCP server contributors receiving injected data)
  ContextRequirementType,
  HyperliquidContext,
  PolymarketContext,
  WalletContext,
  UserContext,
} from "@ctxprotocol/sdk";
```

---

### Tool

```typescript
interface Tool {
  id: string;
  name: string;
  description: string;
  price: string; // Listing-level response price metadata (legacy field name)
  category?: string;
  isVerified?: boolean;
  mcpTools?: McpTool[];
}
```

---

### McpTool

```typescript
interface McpTool {
  name: string;
  description: string;
  inputSchema?: Record<string, unknown>;   // JSON Schema for arguments
  outputSchema?: Record<string, unknown>;  // JSON Schema for response
  _meta?: McpToolMeta;                     // mode/eligibility/pricing/context metadata
  executeEligible?: boolean;               // derived discovery field
  executePriceUsd?: string | null;         // explicit execute price visibility
}

interface McpToolRateLimitHints {
  maxRequestsPerMinute?: number;
  maxConcurrency?: number;
  cooldownMs?: number;
  supportsBulk?: boolean;
  recommendedBatchTools?: string[];
  notes?: string;
}

interface McpToolMeta {
  surface?: "answer" | "execute" | "both";
  queryEligible?: boolean;
  latencyClass?: "instant" | "fast" | "slow" | "streaming";
  pricing?: {
    executeUsd?: string; // required for execute eligibility
    queryUsd?: string;   // optional metadata only in this rollout
  };
  executeEligible?: boolean;
  executePriceUsd?: string;
  contextRequirements?: ContextRequirementType[];
  rateLimit?: McpToolRateLimitHints;
  rateLimitHints?: McpToolRateLimitHints;
}
```

<Info>
For argument guidance, use standard JSON Schema fields directly inside `inputSchema` properties. Put fallback values in `default` and sample invocations in `examples`. Do not rely on custom `_meta.inputExamples`.
</Info>

```typescript
const TOOLS = [{
  name: "get_price_history",
  inputSchema: {
    type: "object",
    properties: {
      symbol: { type: "string", default: "BTC", examples: ["BTC", "ETH", "SOL"] },
      interval: { type: "string", enum: ["1h", "4h", "1d"], default: "1h", examples: ["1h", "4h"] },
      limit: { type: "number", default: 100, examples: [50, 100, 200] },
    },
    required: [],
  },
}];
```

---

### ExecutionResult (Execute Mode)

```typescript
interface ExecutionResult<T = unknown> {
  mode: "execute";
  result: T;
  tool: { id: string; name: string };
  method: { name: string; executePriceUsd: string };
  session: ExecuteSessionSpend;
  durationMs: number;
}
```

### ExecuteSessionSpend

```typescript
interface ExecuteSessionSpend {
  mode: "execute";
  sessionId: string | null;
  methodPrice: string;
  spent: string;
  remaining: string | null;
  maxSpend: string | null;
  status?: "open" | "closed" | "expired";
  expiresAt?: string;
  closeRequested?: boolean;
  pendingAccruedCount?: number;
  pendingAccruedUsd?: string;
}
```

---

### QueryResult (Pay-Per-Response)

```typescript
interface QueryResult {
  response: string;                    // AI-synthesized answer
  toolsUsed: QueryToolUsage[];         // [{ id, name, skillCalls }]
  cost: QueryCost;                     // { modelCostUsd, toolCostUsd, totalCostUsd }
  durationMs: number;
  data?: unknown;                      // Optional execution data (includeData=true)
  dataUrl?: string;                    // Optional blob URL (includeDataUrl=true)
}
```

---

### Context Requirement Types

For MCP server contributors building tools that need user context (e.g., wallet data, portfolio positions):

<Info>
**Why Context Injection Matters:**

- **No Auth Required**: Public blockchain/user data is fetched by the platform, so you don't need to handle API keys or user login.
- **Security**: Your MCP server never handles private keys or sensitive credentials.
- **Simplicity**: You receive structured, type-safe data directly in your tool arguments.
</Info>

```typescript
import type { ContextRequirementType } from "@ctxprotocol/sdk";

/** Context types supported by the marketplace */
type ContextRequirementType = "polymarket" | "hyperliquid" | "wallet";

// Usage: Declare context requirements in _meta at the tool level (MCP spec)
const TOOLS = [{
  name: "analyze_my_positions",
  description: "Analyze your positions with personalized insights",

  // ⭐ REQUIRED: Context requirements in _meta (MCP spec for arbitrary metadata)
  // The Context platform reads this to inject user data + pacing hints
  _meta: {
    contextRequirements: ["hyperliquid"] as ContextRequirementType[],
    rateLimit: {
      maxRequestsPerMinute: 30,
      cooldownMs: 2000,
      maxConcurrency: 1,
      supportsBulk: true,
      recommendedBatchTools: ["get_portfolio_snapshot"],
      notes: "Hobby tier: use snapshot methods before per-asset loops.",
    },
  },

  inputSchema: {
    type: "object",
    properties: {
      portfolio: { 
        type: "object",
        description: "Portfolio context (injected by platform)",
      },
    },
    required: ["portfolio"],
  },
  outputSchema: { /* ... */ },
}];
```

<Info>
**Why `_meta` at the tool level?** The `_meta` field is part of the [MCP specification](https://modelcontextprotocol.io/specification/2025-11-25/server/tools#tool-definition) for arbitrary tool metadata. The Context platform reads `_meta.contextRequirements` for context injection and `_meta.rateLimit` / `_meta.rateLimitHints` for planner/runtime pacing behavior. This is preserved through MCP transport because it's a standard field.
</Info>

<Info>
Reference implementation: [Coinglass contributor server](https://github.com/ctxprotocol/sdk/tree/main/examples/server/coinglass-contributor).
</Info>

<Info>
For when/how to set these fields, see [Tool Metadata](/guides/tool-metadata#rate-limit-hints).
</Info>

---

### Injected Context Types

#### HyperliquidContext

```typescript
interface HyperliquidContext {
  walletAddress: string;
  perpPositions: HyperliquidPerpPosition[];
  spotBalances: HyperliquidSpotBalance[];
  openOrders: HyperliquidOrder[];
  accountSummary: HyperliquidAccountSummary;
  fetchedAt: string;
}
```

#### PolymarketContext

```typescript
interface PolymarketContext {
  walletAddress: string;
  positions: PolymarketPosition[];
  openOrders: PolymarketOrder[];
  totalValue?: number;
  fetchedAt: string;
}
```

#### WalletContext

```typescript
interface WalletContext {
  address: string;
  chainId: number;
  balances: TokenBalance[];
  fetchedAt: string;
}
```

---

## Error Handling

The SDK throws `ContextError` with specific error codes:

```typescript
import { ContextError } from "@ctxprotocol/sdk";

try {
  const result = await client.tools.execute({ ... });
} catch (error) {
  if (error instanceof ContextError) {
    switch (error.code) {
      case "no_wallet":
        // User needs to set up wallet
        console.log("Setup required:", error.helpUrl);
        break;
      case "insufficient_allowance":
        // User needs to set a spending cap
        console.log("Set spending cap:", error.helpUrl);
        break;
      case "payment_failed":
        // Insufficient USDC balance
        break;
      case "execution_failed":
        // Tool execution error
        break;
    }
  }
}
```

### Error Codes

| Code | Description | Handling |
|------|-------------|----------|
| `unauthorized` | Invalid API key | Check configuration |
| `no_wallet` | Wallet not set up | Direct user to `helpUrl` |
| `insufficient_allowance` | Spending cap not set | Direct user to `helpUrl` |
| `payment_failed` | USDC payment failed | Check balance |
| `execution_failed` | Tool error | Retry with different args |

---

## Securing Your Tool (MCP Contributors)

If you're building an MCP server, verify incoming requests are legitimate.

<Info>
**Free vs Paid Security Requirements:**

| Tool Type | Security Middleware | Rationale |
|-----------|---------------------|-----------|
| **Free Tools ($0.00)** | **Optional** | Great for distribution and adoption |
| **Paid Tools ($0.01+)** | **Mandatory** | We cannot route payments to insecure endpoints |
</Info>

### Quick Implementation

```typescript
import express from "express";
import { createContextMiddleware } from "@ctxprotocol/sdk";

const app = express();
app.use(express.json());

// 1 line of code to secure your endpoint
app.use("/mcp", createContextMiddleware());

app.post("/mcp", (req, res) => {
  // req.context contains verified JWT payload (on protected methods)
  // Handle MCP request...
});
```

### MCP Security Model

<Warning>
**Critical for tool contributors:** Not all MCP methods require authentication. The middleware **selectively** protects only execution methods.
</Warning>

| MCP Method | Auth Required | Why |
|------------|---------------|-----|
| `initialize` | ❌ No | Session setup |
| `tools/list` | ❌ No | Discovery - agents need to see your schemas |
| `resources/list` | ❌ No | Discovery |
| `prompts/list` | ❌ No | Discovery |
| `tools/call` | ✅ **Yes** | **Execution - costs money, runs your code** |

<Info>
**What this means in practice:**
- ✅ `https://your-mcp.com/mcp` + `initialize` → Works without auth
- ✅ `https://your-mcp.com/mcp` + `tools/list` → Works without auth  
- ❌ `https://your-mcp.com/mcp` + `tools/call` → **Requires Context Protocol JWT**

This matches standard API patterns (OpenAPI schemas are public, GraphQL introspection is open).
</Info>

### Manual Verification

For more control, use the lower-level utilities:

```typescript
import { 
  verifyContextRequest, 
  isProtectedMcpMethod, 
  ContextError 
} from "@ctxprotocol/sdk";

// Check if a method requires auth
if (isProtectedMcpMethod(body.method)) {
  const payload = await verifyContextRequest({
    authorizationHeader: req.headers.authorization,
    audience: "https://your-tool.com/mcp", // optional
  });
  // payload contains verified JWT claims
}
```

### Verification Options

| Option | Type | Required | Description |
|--------|------|----------|-------------|
| `authorizationHeader` | `string` | Yes | Full Authorization header (e.g., `"Bearer eyJ..."`) |
| `audience` | `string` | No | Expected audience claim for stricter validation |

---

## Payment Flow

Context supports two settlement timings:

1. **Query mode (`client.query.*`)** uses deferred settlement after the response is delivered
2. **Execute mode (`client.tools.execute`)** accrues per-call method spend into execute sessions with automatic batch payment
3. In both modes, spending caps are enforced via ContextRouter allowance checks
4. **90%** goes to the tool developer, **10%** goes to the protocol

---

## Links

- [Context Protocol](https://ctxprotocol.com) — Main website
- [NPM Package](https://www.npmjs.com/package/@ctxprotocol/sdk)
- [GitHub (TypeScript SDK)](https://github.com/ctxprotocol/sdk)
- [Python SDK](/sdk/python-reference) — For Python developers

