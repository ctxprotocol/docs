---
title: "Rate-Limit Metadata"
description: "How to publish _meta.rateLimit hints so Context planners and runtime avoid over-querying your API"
---

<Info>
Use this guide if your MCP server wraps APIs with strict quotas (hobby/free tiers, burst limits, or expensive fan-out endpoints).
</Info>

## Why This Exists

In the marketplace, each contributor has different upstream constraints. Without pacing hints, an agent can generate loops that are valid code but operationally unsafe for your API key tier.

Publishing `_meta.rateLimit` (or `_meta.rateLimitHints`) gives Context two things:

- Better planning (prefer batch/snapshot tools, avoid risky fan-out patterns)
- Safer runtime pacing (respect cooldowns and concurrency intent)

This reduces avoidable `429`/timeout loops and improves first-pass completion.

---

## Metadata Shape

Add these fields to each tool definition under `_meta.rateLimit`:

| Field | Type | Purpose |
|---|---|---|
| `maxRequestsPerMinute` | number | Throughput budget for this tool |
| `cooldownMs` | number | Minimum delay between sequential calls |
| `maxConcurrency` | number | Parallel call ceiling for this tool |
| `supportsBulk` | boolean | Whether the tool already handles batch retrieval |
| `recommendedBatchTools` | string[] | Preferred alternatives to fan-out loops |
| `notes` | string | Human guidance for planner behavior |

---

## TypeScript Example

```typescript
const TOOLS = [
  {
    name: "get_portfolio_snapshot",
    description: "Fetch portfolio snapshot for a wallet",
    _meta: {
      rateLimit: {
        maxRequestsPerMinute: 30,
        cooldownMs: 2000,
        maxConcurrency: 1,
        supportsBulk: true,
        recommendedBatchTools: ["get_portfolio_snapshot"],
        notes: "Hobby tier: prefer snapshot over per-asset fan-out loops.",
      },
    },
    inputSchema: { type: "object", properties: {} },
    outputSchema: { type: "object", properties: {} },
  },
];
```

---

## Python Example

```python
TOOLS = [
    {
        "name": "get_portfolio_snapshot",
        "description": "Fetch portfolio snapshot for a wallet",
        "_meta": {
            "rateLimit": {
                "maxRequestsPerMinute": 30,
                "cooldownMs": 2000,
                "maxConcurrency": 1,
                "supportsBulk": True,
                "recommendedBatchTools": ["get_portfolio_snapshot"],
                "notes": "Hobby tier: prefer snapshot over per-asset fan-out loops.",
            }
        },
        "inputSchema": {"type": "object", "properties": {}},
        "outputSchema": {"type": "object", "properties": {}},
    }
]
```

---

## Contributor Guidance

- Publish hints per tool, not only globally. Heavy fan-out endpoints and lightweight snapshot endpoints should have different guidance.
- Keep `maxConcurrency` conservative for expensive or quota-sensitive endpoints.
- Populate `recommendedBatchTools` whenever you offer a better aggregation endpoint.
- Treat `notes` as planner guidance for real-world constraints (for example, "call alone", "use shallow scan first").

<Warning>
These hints are not a substitute for server-side protections. Keep your own upstream safeguards (timeouts, retries, and pacing) in the MCP server.
</Warning>

---

## Reference Implementations

- TypeScript: [Coinglass contributor server](https://github.com/ctxprotocol/sdk/tree/main/examples/server/coinglass-contributor)
- Python: [Hummingbot contributor server](https://github.com/ctxprotocol/sdk-python/tree/main/examples/server/hummingbot-contributor)
- Additional large-surface example: [Polymarket contributor server](https://github.com/ctxprotocol/sdk/tree/main/examples/server/polymarket-contributor)

