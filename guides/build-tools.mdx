---
title: "Build & List Your Tool"
description: "Step-by-step guide to building an MCP server and listing it on the Context marketplace"
---

## Overview

Want to earn revenue from your data? Build an MCP server and register it as an **MCP Tool** on the Context marketplace.

<Info>
**Earnings Model**: You earn **90%** of every query fee. Set your price (e.g., $0.01/query) and get paid in USDC instantly every time an Agent calls your tool.
</Info>

---

## Step 1: Build a Standard MCP Server

Use the official `@modelcontextprotocol/sdk` to build your server, plus `@ctxprotocol/sdk` to secure your endpoint.

### Install Dependencies

```bash
pnpm add @modelcontextprotocol/sdk express
pnpm add @ctxprotocol/sdk
pnpm add -D @types/express
```

### Implement Structured Output

<Warning>
**Required for Context**: You must implement the MCP structured output standard:
- `outputSchema` in your tool definitions (JSON Schema describing your response structure)
- `structuredContent` in your responses (the machine-readable data matching your schema)
</Warning>

```typescript
// MCP spec compliant server (see: modelcontextprotocol.io/specification)
const TOOLS = [{
  name: "get_gas_price",
  description: "Get current gas prices for any EVM chain",
  inputSchema: {
    type: "object",
    properties: {
      chainId: { type: "number", description: "EVM chain ID" },
    },
  },
  outputSchema: {  // ğŸ‘ˆ Required by Context
    type: "object",
    properties: {
      gasPrice: { type: "number" },
      unit: { type: "string" },
    },
    required: ["gasPrice", "unit"],
  },
}];

// In your tool handler
return {
  content: [{ type: "text", text: JSON.stringify(data) }],  // Backward compat
  structuredContent: data,  // ğŸ‘ˆ Required by Context
};
```

### Secure Your Endpoint

Add Context's middleware to verify that requests are legitimate:

```typescript
import express from "express";
import { createContextMiddleware } from "@ctxprotocol/sdk";

const app = express();
app.use(express.json());

// 1 line of code to secure your endpoint & handle payments
app.use("/mcp", createContextMiddleware());

// ...

// Why this middleware is critical:
// 1. Verifies that requests are signed by the Context Platform (preventing free-riding)
// 2. Injects user context (if requested)
// 3. Handles payment verification automatically
```

### MCP Security Model

<Warning>
**Understanding what's protected:** Not all MCP methods require authentication. Discovery methods are open so agents can find your tools, but execution requires payment verification.
</Warning>

| MCP Method | Auth Required | Why |
|------------|---------------|-----|
| `initialize` | âŒ No | Session setup |
| `tools/list` | âŒ No | Discovery - agents need to see your schemas |
| `resources/list` | âŒ No | Discovery |
| `prompts/list` | âŒ No | Discovery |
| `tools/call` | âœ… **Yes** | **Execution - costs money, runs your code** |

<Info>
**This means:**
- Anyone can call `/mcp` with `initialize` or `tools/list` to discover your tools
- Only requests with a valid Context Protocol JWT can call `tools/call`
- The middleware handles this automatically - you don't need to implement it yourself
</Info>

---

## Step 2: Test Your Tool Locally

Before deploying, ensure your server works as expected. You can use the [official MCP Inspector](https://github.com/modelcontextprotocol/inspector) or `curl` to test your tool locally.

### Using Curl

```bash
# Test your endpoint (assuming it's running on localhost:3000)
curl -X POST http://localhost:3000/mcp \
  -H "Content-Type: application/json" \
  -d '{
    "jsonrpc": "2.0",
    "method": "tools/list",
    "id": 1
  }'
```

---

## Step 3: Deploy Your Server

Your server needs to be **publicly accessible**. We support both transport methods:

| Transport | URL Format | Recommendation |
|-----------|------------|----------------|
| HTTP Streaming | `https://your-server.com/mcp` | âœ… Recommended |
| SSE (Server-Sent Events) | `https://your-server.com/sse` | Supported |

<Tip>
Deploy to any platform: Vercel, Railway, Render, AWS, or your own infrastructure. The only requirement is a publicly accessible HTTPS endpoint.
</Tip>

---

## Step 3: Register in the App

<Steps>
  <Step title="Go to /contribute">
    Navigate to the contribute page in the running Context app
  </Step>
  <Step title="Select MCP Tool">
    Choose "MCP Tool" (the default option)
  </Step>
  <Step title="Paste Your Endpoint URL">
    Enter your publicly accessible endpoint URL
  </Step>
  <Step title="Auto-Discovery">
    We'll auto-discover your skills via `listTools()`
  </Step>
</Steps>

---

## Step 4: Set a Price

Choose your fee per query:

| Price | Use Case |
|-------|----------|
| **$0.00** | Free tools (great for adoption and visibility) |
| **$0.01+** | Paid tools (earn revenue per query) |

<Note>
This fee is paid **once per chat turn**. The Agent can call your skills up to 100 times within that single paid turn via `callMcpSkill()`.
</Note>

---

## Step 5: Stake USDC

All tools require a minimum USDC stake, enforced on-chain.

| Tool Type | Minimum Stake |
|-----------|---------------|
| Free Tools | $10 USDC |
| Paid Tools | $10 USDC or 100Ã— query price (whichever is higher) |

<Info>
Stakes are **fully refundable** with a 7-day withdrawal delay. This creates accountability and enables slashing for fraud.
</Info>

---

## Step 6: You're Live! ğŸ‰

Your MCP Tool is now instantly available on the decentralized marketplace. Users can discover it via search, and AI agents can autonomously purchase and use your tool.

---

## Schema Accuracy & Dispute Resolution

<Warning>
Your `outputSchema` isn't just documentation â€” **it's a contract**.
</Warning>

Context uses automated schema validation as part of our crypto-native dispute resolution system:

1. Users can dispute tool outputs by providing their `transaction_hash` (proof of payment)
2. **Robot judge** auto-adjudicates by validating your actual output against your declared `outputSchema`
3. If schema mismatches, the dispute is resolved against you automatically
4. Repeated violations (5+ flags) lead to tool deactivation

### Example: Schema Compliance

```typescript
// âŒ BAD: Schema says number, but you return string
outputSchema: { temperature: { type: "number" } }
structuredContent: { temperature: "72" }  // GUILTY - schema mismatch!

// âœ… GOOD: Output matches schema exactly
outputSchema: { temperature: { type: "number" } }
structuredContent: { temperature: 72 }  // Valid
```

<Tip>
**Why this matters**: Unlike Web2 "star ratings" that can be gamed by bots, Context disputes require **economic proof** (you paid for the query). This protects honest developers from spam while ensuring bad actors face consequences.
</Tip>

---

## Execution Limits & Product Design

<Warning>
**Critical**: MCP tool execution on the Context platform has a **~60 second timeout**. This is intentional â€” it shapes the marketplace toward high-quality data products.
</Warning>

### Where the Timeout Comes From

The timeout is enforced by the **platform infrastructure** (and in standard MCP setups like Claude Desktop, by the LLM client itself). When your tool is called, the system waits for a response â€” if it doesn't arrive in ~60 seconds, execution fails.

<Note>
This isn't an MCP protocol limitation â€” SSE connections can stay open indefinitely. The timeout exists at the application layer (LLM clients, API gateways, platform infrastructure) and serves as a **quality forcing function**.
</Note>

### Why the Timeout Is Actually Good

The timeout isn't a bug â€” it's a feature that forces data brokers to build **actual products** instead of raw data access.

| Raw Access (âŒ Bad Product) | Data Broker Product (âœ… Good Product) |
|----------------------------|--------------------------------------|
| "Run any SQL on Dune" | "Smart Money Wallet Tracker" |
| "Query 4 years of NFT data" | "NFT Alpha Signals" |
| "Scan all whale wallets" | "Whale Alert Feed" |
| Timeout after 60s âŒ | Instant response âœ… |

<Note>
**The reframe**: The best data businesses don't sell raw database access. They sell curated, **pre-computed insights**. This is exactly how Bloomberg, Nansen, Arkham, and Messari work.
</Note>

### The Data Broker Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    DATA BROKER'S JOB (offline)                      â”‚
â”‚                                                                     â”‚
â”‚  1. Run heavy queries on your data source (30 min timeout - OK)    â”‚
â”‚  2. Pre-compute valuable insights ("wallets that sold tops")       â”‚
â”‚  3. Store results in your own database                             â”‚
â”‚  4. Update daily/hourly via cron jobs                              â”‚
â”‚                                                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    MCP TOOL (instant)                               â”‚
â”‚                                                                     â”‚
â”‚  User: "What are the smart money wallets holding?"                 â”‚
â”‚  Tool: SELECT * FROM my_precomputed_smart_money LIMIT 10           â”‚
â”‚  Response: < 1 second âœ…                                            â”‚
â”‚                                                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Product Tiers

<AccordionGroup>
  <Accordion title="Tier 1: Real-time Queries (< 60s)" icon="bolt">
    Perfect for MCP â€” works great today:
    - Current prices, recent trades, portfolio snapshots
    - "What's in Vitalik's wallet right now?"
    - "Get current gas prices on Ethereum"
    
    **Implementation**: Direct API calls that return quickly
  </Accordion>
  
  <Accordion title="Tier 2: Pre-computed Insights (instant)" icon="database">
    **This is the REAL product** â€” where data brokers add massive value:
    - "Smart money wallets" (pre-computed daily)
    - "Whale alerts" (pre-computed hourly)
    - "NFT trending collections" (pre-computed)
    
    **Implementation**: Heavy queries run offline via cron, results served instantly via MCP
  </Accordion>
  
  <Accordion title="Tier 3: Async Jobs (future)" icon="clock">
    For heavy analysis that can't be pre-computed:
    - User submits query â†’ gets job ID
    - Polls for results (or webhook callback)
    - Results stored for later retrieval
    
    **Implementation**: 
    ```typescript
    // Submit job
    { name: "submit_analysis_job", returns: { jobId: "abc123", estimatedTime: "5 min" } }
    
    // Get results
    { name: "get_job_results", args: { jobId: "abc123" } }
    ```
  </Accordion>
</AccordionGroup>

### Example: Good vs Bad Tool Design

```typescript
// âŒ BAD: Raw SQL tool (timeout-prone, no moat)
{
  name: "run_sql",
  description: "Run any SQL against blockchain data"
  // This is a demo, not a product
}

// âœ… GOOD: Pre-computed insight tools
{
  name: "get_smart_money_wallets",
  description: "Get top 100 wallets that historically timed market tops",
  // Data broker pre-computes this daily, serves instantly
}

{
  name: "get_whale_holdings",
  description: "Current holdings of known whale wallets",
  // Pre-computed hourly, instant response
}
```

<Tip>
**The value you create**: Your data brokers should be selling "Nansen-as-a-service" and "Arkham-as-a-service" â€” not raw SQL access. The timeout forces this quality bar.
</Tip>

### Why This Is BETTER for the Marketplace

| Raw SQL Model | Data Broker Product Model |
|---------------|--------------------------|
| Anyone can build (no moat) | Requires expertise (defensible) |
| Competes on price (race to bottom) | Competes on quality (premium pricing) |
| Users frustrated by timeouts | Users delighted by instant results |
| Data broker adds no value | Data broker adds **massive** value |

---

## Complete Server Example

Here's a full working example of an MCP server ready for Context:

```typescript
import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { SSEServerTransport } from "@modelcontextprotocol/sdk/server/sse.js";
import express from "express";
import { createContextMiddleware } from "@ctxprotocol/sdk";

const app = express();
app.use(express.json());

// Secure endpoint with Context middleware
app.use("/mcp", createContextMiddleware());

// Define tools with outputSchema
const TOOLS = [{
  name: "get_gas_price",
  description: "Get current gas prices",
  inputSchema: {
    type: "object",
    properties: {
      chainId: { type: "number", description: "EVM chain ID" },
    },
  },
  outputSchema: {
    type: "object",
    properties: {
      gasPrice: { type: "number" },
      unit: { type: "string" },
    },
    required: ["gasPrice", "unit"],
  },
}];

// Standard MCP server setup
const server = new Server(
  { name: "my-gas-tool", version: "1.0.0" },
  { capabilities: { tools: {} } }
);

server.setRequestHandler(ListToolsRequestSchema, async () => ({
  tools: TOOLS,
}));

server.setRequestHandler(CallToolRequestSchema, async (request) => {
  const data = await fetchGasData(request.params.arguments.chainId);
  
  return {
    content: [{ type: "text", text: JSON.stringify(data) }],
    structuredContent: data,
  };
});

app.listen(3000, () => {
  console.log("MCP server running on port 3000");
});
```

---

## Example Servers

Check out these complete working examples:

### TypeScript (Express + MCP SDK)

<CardGroup cols={3}>
  <Card title="Blocknative" icon="gas-pump" href="https://github.com/ctxprotocol/sdk/tree/main/examples/server/blocknative-contributor">
    Gas price API (3 tools)
  </Card>
  <Card title="Hyperliquid" icon="chart-line" href="https://github.com/ctxprotocol/sdk/tree/main/examples/server/hyperliquid-contributor">
    DeFi analytics (16 tools)
  </Card>
  <Card title="Polymarket" icon="chart-pie" href="https://github.com/ctxprotocol/sdk/tree/main/examples/server/polymarket-contributor">
    Prediction market intelligence
  </Card>
</CardGroup>

### Python (FastMCP + ctxprotocol)

<CardGroup cols={2}>
  <Card title="Hummingbot Market Intel" icon="python" href="https://github.com/ctxprotocol/sdk-python/tree/main/examples/server/hummingbot-contributor">
    Multi-exchange market data (6 tools) â€” prices, order books, funding rates, trade impact analysis
  </Card>
</CardGroup>

<Tip>
The Python example uses [FastMCP](https://gofastmcp.com) which auto-generates `outputSchema` from Pydantic models and includes `structuredContent` in responses automatically.
</Tip>

